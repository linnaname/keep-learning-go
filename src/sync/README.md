同步工具

Once 确保操作只做一次，实现原理也很简单，一个计数器，一把锁

`type Once struct {

     done uint32
     m    Mutex
 }`
 
注意：do方法调用后，无论是否成功都不能再使用该Once了，如果有多个函数需要调用一次，那么就应该再生成一个




WaitGroup 用来阻塞主协程，可以等待所有协程执行完。类似Java的Semaphore,几点可以注意的：
1.add和wait要在同一个goroutine中调用

2.在sub goroutine中调用done

3.可以在wait后继续复用

设计上居然不是和Once同样的思想，有点出乎我意料。使用state字段，高32位是counter, 低32位是等待者的数量。
这样的高低位利用倒是很像Java的设计。add和done方法都是通过atomic来操作counter实现。


mutex 锁，注意几点
1.不可重入，多次Lock会死锁

2.mutex在传递给外部使用的时候，需要传指针,不然传的是拷贝，会引起锁失败。并且指针的mutex是一定要实例化过的。

3.使用defer释放锁的话会比显示调用Unlock成本高

设计上还是基于CPU的支持的LOCK命令，内存屏障、禁止重排序等等，基于atomic.CAS+cpu时钟周期阻塞。同时做了一些优化包括：

1.设置了一定的自旋周期
2.用信号量实现睡眠的协程唤起让协程等待的代价要比线程更低，而且协程上下文切换也更快一些
3.增加饥饿模式避免无效唤起

RWMutex 读写锁，需要注点的几点

1.对一个RWLock进行同时Lock()和RLock()会死锁.这意味着如果一个操作函数里同时包含写和读

2.读锁可以被获取多次，而写锁仅能被获取一次，读锁很像一个引用计数器，写锁其实就是个Mutex全局锁

3.为了避免一直有读锁占锁，写锁加不上导致的饥饿问题，写锁优先级较高

4.随核心数升高其性能伸展性不佳

设计上，写锁就是一个mutex,读锁有cnt统计，基于信号量PV操作


Cond  提供了阻塞和唤醒函数，跟Java的也没看出什么差别,获取该锁之后才调用Wait()方法

实现上依赖于runtime阻塞和唤醒go协程的函数，暂时不看